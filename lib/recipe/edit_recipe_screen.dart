import 'dart:io';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
// import 'package:supabase_flutter/supabase_flutter.dart'; // Tidak digunakan secara langsung di sini
import '../services/image_upload_service.dart';
import '../services/recipe_service.dart';
import '../models/recipe_model.dart';
import '../models/tag_models.dart'; // Added import for tag models
import '../services/supabase_client.dart'; // Untuk SupabaseClientWrapper().auth.currentUser

// Data class for managing individual ingredient row inputs (copied from create_recipe_screen.dart)
// Consider moving to a shared models file if this project grows.
class IngredientRowData {
  final UniqueKey id;
  final TextEditingController nameController;
  final TextEditingController quantityController;
  final TextEditingController unitController;

  IngredientRowData({
    String initialName = '',
    String initialQuantity = '',
    String initialUnit = '',
    // required this.id, // id is generated by UniqueKey()
  }) : id = UniqueKey(),
       nameController = TextEditingController(text: initialName),
       quantityController = TextEditingController(text: initialQuantity),
       unitController = TextEditingController(text: initialUnit);

  void dispose() {
    nameController.dispose();
    quantityController.dispose();
    unitController.dispose();
  }

  bool get isEmpty {
    return nameController.text.trim().isEmpty &&
           quantityController.text.trim().isEmpty &&
           unitController.text.trim().isEmpty;
  }
}

// Copied from create_recipe_screen.dart
class InstructionStepData {
  final UniqueKey id;
  final TextEditingController textController;
  File? selectedImageFile;
  String? existingImageUrl; // To hold URL of image already part of the recipe

  InstructionStepData({
    String initialText = '',
    this.selectedImageFile,
    this.existingImageUrl,
  }) : id = UniqueKey(), textController = TextEditingController(text: initialText);

  void dispose() {
    textController.dispose();
  }
}

class EditRecipeScreen extends StatefulWidget {
  final int recipeId; // Changed from RecipeModel to recipeId

  const EditRecipeScreen({super.key, required this.recipeId}); // Updated constructor

  @override
  State<EditRecipeScreen> createState() => _EditRecipeScreenState();
}

class _EditRecipeScreenState extends State<EditRecipeScreen> {
  final _formKey = GlobalKey<FormState>();

  // State variables for the fetched recipe and loading state
  RecipeModel? _recipe;
  bool _isLoading = true;
  String _loadingError = '';
  final RecipeService _recipeService = RecipeService(); // Instance of RecipeService

  // Controllers will be initialized after data is fetched
  late TextEditingController _titleController;
  late TextEditingController _descriptionController;

  File? _newSelectedImageFile;
  String? _existingImageUrl;

  final ImagePicker _picker = ImagePicker();
  final ImageUploadService _imageUploadService = ImageUploadService();
  // final RecipeService _recipeService = RecipeService(); // Removed duplicate
  bool _isUploadingOrSaving = false;

  late TextEditingController _caloriesController;
  late TextEditingController _servingsController;
  late TextEditingController _cookingMinutesController;
  String? _selectedDifficultyLevel;
  List<IngredientRowData> _ingredientRows = [];
  // late TextEditingController _directionsController; // Replaced by _instructionSteps
  List<InstructionStepData> _instructionSteps = []; // For new instruction handling

  List<String> _existingGalleryImageUrls = [];
  final List<File> _newSelectedGalleryImageFiles = [];

  // State for tags - these are re-assigned in _fetchTags
  List<Allergen> _availableAllergens = [];
  List<DietProgram> _availableDietPrograms = [];
  List<Equipment> _availableEquipment = [];

  final Set<int> _selectedAllergenIds = {}; // Made final
  final Set<int> _selectedDietProgramIds = {}; // Made final
  final Set<int> _selectedEquipmentIds = {}; // Made final
  bool _isLoadingTags = true;

  @override
  void initState() {
    super.initState();
    _fetchRecipeDetailsAndInitializeForm();
  }

  Future<void> _fetchRecipeDetailsAndInitializeForm() async {
    setState(() {
      _isLoading = true;
      _loadingError = '';
    });
    try {
      final String? currentUserId = SupabaseClientWrapper().client.auth.currentUser?.id;
      // Use the same service call as RecipeDetailScreen
      final recipeDataMap = await _recipeService.getRecipeDetailsById(widget.recipeId, currentUserId: currentUserId);
      
      if (!mounted) return;

      // Adapt the map to RecipeModel using its fromJson factory
      // This factory is expected to handle nested lists like recipe_ingredients, recipe_instructions, allergens etc.
      _recipe = RecipeModel.fromJson(recipeDataMap);

      // Initialize controllers and state variables *after* _recipe is set
      _titleController = TextEditingController(text: _recipe!.title);
      _descriptionController = TextEditingController(text: _recipe!.description);
      _existingImageUrl = _recipe!.image_url;
      _caloriesController = TextEditingController(text: _recipe!.calories?.toString() ?? '');
      _servingsController = TextEditingController(text: _recipe!.servings.toString());
      _cookingMinutesController = TextEditingController(text: _recipe!.cooking_time_minutes.toString());
      _selectedDifficultyLevel = _recipe!.difficulty_level;

      if (_recipe!.ingredients != null && _recipe!.ingredients!.isNotEmpty) {
        _ingredientRows = _recipe!.ingredients!.map((ingModel) {
          return IngredientRowData(
            initialName: ingModel.ingredient_text,
            initialQuantity: ingModel.quantity.toString(),
            initialUnit: ingModel.unit ?? '',
          );
        }).toList();
      } else {
        _ingredientRows.add(IngredientRowData());
      }

      if (_recipe!.instructions != null && _recipe!.instructions!.isNotEmpty) {
        _instructionSteps = _recipe!.instructions!.map((instrModel) {
          return InstructionStepData(
            initialText: instrModel.instruction,
            existingImageUrl: instrModel.image_url,
          );
        }).toList();
      } else if (_recipe!.directions_text != null && _recipe!.directions_text!.trim().isNotEmpty) {
        final lines = _recipe!.directions_text!
            .split(RegExp(r'\r\n|\r|\n'))
            .where((line) => line.trim().isNotEmpty);
        _instructionSteps = lines.map((line) => InstructionStepData(initialText: line.trim())).toList();
      }
      if (_instructionSteps.isEmpty) {
        _instructionSteps.add(InstructionStepData());
      }

      _existingGalleryImageUrls = List<String>.from(_recipe!.gallery_image_urls ?? []);
      
      // Fetch available tags and populate selected ones
      await _fetchTagsAndPopulateSelected(); // This now uses _recipe internally

      setState(() {
        _isLoading = false;
      });

    } catch (e, s) {
      print("Error fetching recipe details for edit: $e");
      print("Stack trace: $s");
      if (!mounted) return;
      setState(() {
        _isLoading = false;
        _loadingError = "Gagal memuat detail resep untuk diedit: ${e.toString()}";
      });
    }
  }

  Future<void> _fetchTagsAndPopulateSelected() async {
    // This method now assumes _recipe is already populated.
    if (_recipe == null) {
      setState(() { _isLoadingTags = false; });
      return;
    }
    setState(() { _isLoadingTags = true; });
    try {
      final allergens = await _recipeService.getAllergens();
      final dietPrograms = await _recipeService.getDietPrograms();
      final equipment = await _recipeService.getEquipment();

      if (!mounted) return;
      
      _availableAllergens = allergens;
      _availableDietPrograms = dietPrograms;
      _availableEquipment = equipment;

      _selectedAllergenIds.clear();
      _selectedAllergenIds.addAll(_recipe!.allergensList?.map((a) => a.id).toSet() ?? {});
      _selectedDietProgramIds.clear();
      _selectedDietProgramIds.addAll(_recipe!.dietProgramsList?.map((dp) => dp.id).toSet() ?? {});
      _selectedEquipmentIds.clear();
      _selectedEquipmentIds.addAll(_recipe!.equipmentList?.map((e) => e.id).toSet() ?? {});
      
      setState(() { _isLoadingTags = false; });
    } catch (e) {
      print("Error fetching tags: $e");
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Gagal memuat informasi tag: $e')),
      );
      setState(() { _isLoadingTags = false; });
    }
  }

  @override
  void dispose() {
    // Dispose controllers only if they have been initialized
    if (_recipe != null) {
      _titleController.dispose();
      _descriptionController.dispose();
      _caloriesController.dispose();
      _servingsController.dispose();
      _cookingMinutesController.dispose();
      for (var row in _ingredientRows) {
        row.dispose();
      }
      for (var step in _instructionSteps) {
        step.dispose();
      }
    }
    super.dispose();
  }

  Future<void> _pickInstructionImage(int index) async {
    if (_isUploadingOrSaving) return;
    final XFile? pickedFile = await _picker.pickImage(source: ImageSource.gallery);
    if (pickedFile != null && mounted) {
      setState(() {
        _instructionSteps[index].selectedImageFile = File(pickedFile.path);
        _instructionSteps[index].existingImageUrl = null; // Clear existing if new one is picked
      });
    }
  }

  double _parseQuantity(String quantityStr) { // Copied from create_recipe_screen
    quantityStr = quantityStr.trim().replaceAll(',', '.');
    if (quantityStr.isEmpty) return 1.0;

    if (quantityStr.contains('/')) {
        final parts = quantityStr.split(' ');
        double totalQuantity = 0;
        if (parts.length > 1) {
            totalQuantity += double.tryParse(parts[0]) ?? 0;
            final fractionParts = parts[1].split('/');
            if (fractionParts.length == 2) {
                double numerator = double.tryParse(fractionParts[0]) ?? 0;
                double denominator = double.tryParse(fractionParts[1]) ?? 1;
                if (denominator != 0) {
                    totalQuantity += numerator / denominator;
                }
            }
        } else {
            final fractionParts = quantityStr.split('/');
            if (fractionParts.length == 2) {
                double numerator = double.tryParse(fractionParts[0]) ?? 0;
                double denominator = double.tryParse(fractionParts[1]) ?? 1;
                if (denominator != 0) {
                    totalQuantity = numerator / denominator;
                } else {
                    totalQuantity = 0;
                }
            } else {
                 return double.tryParse(quantityStr) ?? 1.0;
            }
        }
        return totalQuantity > 0 ? totalQuantity : 1.0;
    } else {
        return double.tryParse(quantityStr) ?? 1.0;
    }
}


  Future<void> _saveChanges() async {
     if (_newSelectedImageFile == null && (_existingImageUrl == null || _existingImageUrl!.isEmpty)) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Gambar utama resep tidak boleh kosong.')),
      );
      return;
    }

    if (_selectedDifficultyLevel == null) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Silakan pilih tingkat kesulitan.')),
      );
      return;
    }

    if (!_formKey.currentState!.validate()) {
       if (!mounted) return;
       ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Harap perbaiki kesalahan dalam formulir sebelum menyimpan.')),
      );
      return;
    }
    _formKey.currentState!.save();

    if (_recipe == null) { // Should not happen if UI is built, but good check
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Data resep tidak ditemukan.')),
      );
      return;
    }

    final currentUser = SupabaseClientWrapper().auth.currentUser;
    if (currentUser == null) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Anda harus masuk untuk mengedit resep.')),
      );
      return;
    }

    if (_recipe!.user_id != currentUser.id) { // Use _recipe.user_id
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Anda tidak berwenang untuk mengedit resep ini.')),
        );
        return;
    }
     if (_instructionSteps.isEmpty || _instructionSteps.every((step) => step.textController.text.trim().isEmpty)) {
       if (!mounted) return;
       ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Silakan tambahkan minimal satu langkah instruksi dengan teks.')),
      );
      return;
    }


    if (_isUploadingOrSaving) return;

    setState(() {
      _isUploadingOrSaving = true;
    });

    String? finalMainImageUrl = _existingImageUrl;
    if (_newSelectedImageFile != null) {
      finalMainImageUrl = await _imageUploadService.uploadImage(_newSelectedImageFile!);
      if (finalMainImageUrl == null) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Unggah gambar utama resep gagal. Silakan coba lagi.')),
        );
        setState(() { _isUploadingOrSaving = false; });
        return;
      }
    }

    List<String> finalGalleryImageUrls = List.from(_existingGalleryImageUrls);

    if (_newSelectedGalleryImageFiles.isNotEmpty) {
      for (File imageFile in _newSelectedGalleryImageFiles) {
        String? url = await _imageUploadService.uploadImage(imageFile);
        if (url != null) {
          finalGalleryImageUrls.add(url);
        } else {
           if (!mounted) return;
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text('Sebuah gambar galeri baru gagal diunggah dan dilewati.')),
            );
        }
      }
    }

    // Process new Instructions from _instructionSteps
    List<RecipeInstructionModel> finalInstructions = [];
    String directionsTextConcatenated = ""; // For RecipeModel.directions_text (legacy or display)

    for (int i = 0; i < _instructionSteps.length; i++) {
      InstructionStepData stepData = _instructionSteps[i];
      String instructionText = stepData.textController.text.trim();
      String? imageUrl = stepData.existingImageUrl; // Start with existing image

      if (stepData.selectedImageFile != null) { // New image was picked for this step
        final String? uploadedUrl = await _imageUploadService.uploadImage(stepData.selectedImageFile!);
        if (uploadedUrl != null) {
          imageUrl = uploadedUrl;
          // TODO: Consider deleting the old image if `stepData.existingImageUrl` was not null and different.
        } else {
          if (!mounted) return;
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Gagal mengunggah gambar untuk langkah ${i + 1}. Gambar lama (jika ada) akan dipertahankan atau langkah tanpa gambar baru.')),
          );
          // imageUrl remains stepData.existingImageUrl or null if it was already null
        }
      }
      // If instructionText is empty but there's an image, it's often undesirable.
      // Create_recipe_screen skips such steps. Here, we might allow it if an image exists.
      // However, to align with create, let's ensure text is present if we are to save the step.
      if (instructionText.isNotEmpty) {
        finalInstructions.add(RecipeInstructionModel(
          // id: if this instruction existed before, its ID should be preserved for Supabase update.
          // This requires RecipeInstructionModel to have an optional ID and for InstructionStepData
          // to potentially store this ID if populated from an existing instruction.
          // For simplicity now, we are not handling instruction ID preservation for updates,
          // which means old instructions might be deleted and new ones created.
          // This is a common simplification but can be improved.
          step_number: i + 1,
          instruction: instructionText,
          image_url: imageUrl,
        ));
        directionsTextConcatenated += "$instructionText\n";
      } else if (imageUrl != null && instructionText.isEmpty) {
          if (!mounted) return;
          ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Langkah instruksi ${i + 1} memiliki gambar tetapi tidak ada teks. Langkah ini dilewati.')),
          );
      }
    }
     if (finalInstructions.isEmpty && _instructionSteps.any((s) => s.textController.text.trim().isNotEmpty || s.existingImageUrl != null || s.selectedImageFile != null)) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Mohon pastikan minimal satu langkah instruksi memiliki teks.')));
        setState(() { _isUploadingOrSaving = false; });
        return;
    }


    // Process Ingredients from _ingredientRows
    List<RecipeIngredientModel> processedIngredients = [];
    String ingredientsTextConcatenated = "";

    for (int i = 0; i < _ingredientRows.length; i++) {
      final row = _ingredientRows[i];
      final name = row.nameController.text.trim();
      final quantityStr = row.quantityController.text.trim();
      final unit = row.unitController.text.trim();

      if (name.isEmpty && quantityStr.isEmpty && unit.isEmpty) {
        continue; 
      }
      if (name.isEmpty) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Nama bahan di baris ${i + 1} tidak boleh kosong jika baris tidak sepenuhnya kosong.')));
        setState(() { _isUploadingOrSaving = false; });
        return;
      }
      if (quantityStr.isEmpty) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Jumlah bahan di baris ${i + 1} tidak boleh kosong jika nama bahan diisi.')));
        setState(() { _isUploadingOrSaving = false; });
        return;
      }
      double quantity = _parseQuantity(quantityStr);
       if (quantity <= 0 && quantityStr.isNotEmpty) {
           if (!mounted) return;
           ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Jumlah bahan "$name" tidak valid (harus lebih besar dari 0).')));
           setState(() { _isUploadingOrSaving = false; });
           return;
      }

      processedIngredients.add(RecipeIngredientModel(
        ingredient_text: name,
        quantity: quantity,
        unit: unit.isNotEmpty ? unit : null,
        order_index: processedIngredients.length,
      ));
      ingredientsTextConcatenated += "$quantityStr $unit $name\n";
    }
     if (processedIngredients.isEmpty && _ingredientRows.any((row) => !row.isEmpty)) {
       if (!mounted) return;
       ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Mohon masukkan minimal satu bahan dengan nama dan jumlah yang valid.')));
       setState(() { _isUploadingOrSaving = false; });
       return;
    }
    if (processedIngredients.isEmpty && _ingredientRows.every((row) => row.isEmpty) && _ingredientRows.isNotEmpty) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Resep harus memiliki minimal satu bahan.')));
        setState(() { _isUploadingOrSaving = false; });
        return;
    }


    RecipeModel recipeToUpdate = RecipeModel(
      id: _recipe!.id, // Use _recipe.id
      user_id: _recipe!.user_id, // Use _recipe.user_id
      title: _titleController.text,
      description: _descriptionController.text,
      image_url: finalMainImageUrl,
      calories: int.tryParse(_caloriesController.text), // Use tryParse for safety
      servings: int.tryParse(_servingsController.text) ?? 1, // Use tryParse and provide default
      cooking_time_minutes: int.tryParse(_cookingMinutesController.text) ?? 0, // Use tryParse and provide default
      difficulty_level: _selectedDifficultyLevel!,
      is_published: _recipe!.is_published, // Use _recipe.is_published
      created_at: _recipe!.created_at, // Use _recipe.created_at
      ingredients_text: ingredientsTextConcatenated.trim().isNotEmpty ? ingredientsTextConcatenated.trim() : null,
      directions_text: directionsTextConcatenated.trim().isNotEmpty ? directionsTextConcatenated.trim() : null,
      instructions: finalInstructions.isNotEmpty ? finalInstructions : null,
      gallery_image_urls: finalGalleryImageUrls.isNotEmpty ? finalGalleryImageUrls : null,
      selectedAllergenIds: _selectedAllergenIds.toList(),
      selectedDietProgramIds: _selectedDietProgramIds.toList(),
      selectedEquipmentIds: _selectedEquipmentIds.toList(),
      // Explicitly pass ingredients
      ingredients: processedIngredients.isNotEmpty ? processedIngredients : null,
    );

    try {
      await _recipeService.updateRecipe(recipeToUpdate, finalGalleryImageUrls);
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Resep berhasil diperbarui!')),
      );
      Navigator.pop(context, true);
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Gagal memperbarui resep: $e')),
      );
    } finally {
      if (mounted) { // Check mounted before final setState
        setState(() {
          _isUploadingOrSaving = false;
        });
      }
    }
  }

  Future<void> _pickImage() async {
    if (_isUploadingOrSaving) return;
    final XFile? pickedFile = await _picker.pickImage(source: ImageSource.gallery);
    if (pickedFile != null) {
      setState(() {
        _newSelectedImageFile = File(pickedFile.path);
      });
    }
  }

  Future<void> _pickGalleryImages() async {
    if (_isUploadingOrSaving) return;
    final List<XFile> pickedFiles = await _picker.pickMultiImage();
    if (pickedFiles.isNotEmpty) {
      setState(() {
        _newSelectedGalleryImageFiles.addAll(pickedFiles.map((xf) => File(xf.path)).toList());
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final textStyle = GoogleFonts.dmSans(fontSize: 16);
    final labelStyle = GoogleFonts.dmSans(fontSize: 14, color: Colors.grey[700]);

    if (_isLoading) {
      return Scaffold(
        appBar: AppBar(title: Text('Memuat Resep...', style: GoogleFonts.dmSans(fontWeight: FontWeight.bold))),
        body: const Center(child: CircularProgressIndicator()),
      );
    }

    if (_loadingError.isNotEmpty) {
      return Scaffold(
        appBar: AppBar(title: Text('Error Memuat Resep', style: GoogleFonts.dmSans(fontWeight: FontWeight.bold))),
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(_loadingError, style: const TextStyle(color: Colors.red, fontSize: 16), textAlign: TextAlign.center),
          ),
        ),
      );
    }

    if (_recipe == null) { // Should be caught by _loadingError, but as a fallback
      return Scaffold(
        appBar: AppBar(title: Text('Resep Tidak Ditemukan', style: GoogleFonts.dmSans(fontWeight: FontWeight.bold))),
        body: const Center(child: Text("Detail resep tidak dapat dimuat.")),
      );
    }

    // If we reach here, _recipe is not null and we are not loading/error.
    return Scaffold(
      appBar: AppBar(
        title: Text('Edit Resep: ${_recipe!.title}', style: GoogleFonts.dmSans(fontWeight: FontWeight.bold)),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        elevation: 1,
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: <Widget>[
                TextFormField(
                  key: const Key('title_field'),
                  controller: _titleController,
                  style: textStyle,
                  decoration: InputDecoration(labelText: 'Judul Resep*', labelStyle: labelStyle),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Judul resep tidak boleh kosong';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                TextFormField(
                  key: const Key('description_field'),
                  controller: _descriptionController,
                  style: textStyle,
                  decoration: InputDecoration(labelText: 'Deskripsi Resep*', labelStyle: labelStyle),
                  maxLines: 3,
                  keyboardType: TextInputType.multiline,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Deskripsi resep tidak boleh kosong';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 24),

                // Tags Section (Opsional)
                if (_isLoadingTags)
                  const Center(child: CircularProgressIndicator())
                else ...[
                  _buildTagSelectionSection<Allergen>(
                    title: 'Alergen (Pilih jika ada)',
                    availableTags: _availableAllergens,
                    selectedTagIds: _selectedAllergenIds,
                    onSelected: (selected, tagId) {
                      setState(() {
                        if (selected) {
                          _selectedAllergenIds.add(tagId);
                        } else {
                          _selectedAllergenIds.remove(tagId);
                        }
                      });
                    },
                  ),
                  const SizedBox(height: 16),
                  _buildTagSelectionSection<DietProgram>(
                    title: 'Program Diet (Pilih jika sesuai)',
                    availableTags: _availableDietPrograms,
                    selectedTagIds: _selectedDietProgramIds,
                    onSelected: (selected, tagId) {
                      setState(() {
                        if (selected) {
                          _selectedDietProgramIds.add(tagId);
                        } else {
                          _selectedDietProgramIds.remove(tagId);
                        }
                      });
                    },
                  ),
                  const SizedBox(height: 16),
                  _buildTagSelectionSection<Equipment>(
                    title: 'Peralatan yang Dibutuhkan (Pilih jika ada)',
                    availableTags: _availableEquipment,
                    selectedTagIds: _selectedEquipmentIds,
                    onSelected: (selected, tagId) {
                      setState(() {
                        if (selected) {
                          _selectedEquipmentIds.add(tagId);
                        } else {
                          _selectedEquipmentIds.remove(tagId);
                        }
                      });
                    },
                  ),
                ],
                const SizedBox(height: 16),

                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text("Gambar Utama Resep*", style: GoogleFonts.dmSans(fontSize: 16, fontWeight: FontWeight.bold)),
                      const SizedBox(height: 8),
                      if (_newSelectedImageFile != null)
                        Container(
                          height: 200,
                          width: double.infinity,
                          decoration: BoxDecoration(
                            border: Border.all(color: Colors.grey),
                            image: DecorationImage(image: FileImage(_newSelectedImageFile!), fit: BoxFit.cover),
                          ),
                          margin: const EdgeInsets.only(bottom: 8.0),
                        )
                      else if (_existingImageUrl != null && _existingImageUrl!.isNotEmpty)
                        Container(
                          height: 200,
                          width: double.infinity,
                          decoration: BoxDecoration(
                            border: Border.all(color: Colors.grey),
                            image: DecorationImage(image: NetworkImage(_existingImageUrl!), fit: BoxFit.cover),
                          ),
                          margin: const EdgeInsets.only(bottom: 8.0),
                        )
                      else // Placeholder if no image exists and none selected
                        Container(
                          height: 100,
                          width: double.infinity,
                           decoration: BoxDecoration(
                            border: Border.all(color: Colors.grey[400]!),
                            borderRadius: BorderRadius.circular(4.0)
                          ),
                          child: Center(child: Text("Tidak ada gambar utama", style: labelStyle)),
                          margin: const EdgeInsets.only(bottom: 8.0),
                        ),
                      ElevatedButton.icon(
                        key: const Key('pick_image_button_edit'),
                        onPressed: _isUploadingOrSaving ? null : _pickImage,
                        icon: const Icon(Icons.image),
                        label: Text((_existingImageUrl != null && _existingImageUrl!.isNotEmpty) || _newSelectedImageFile != null ? 'Ganti Gambar Utama' : 'Pilih Gambar Utama'),
                        style: ElevatedButton.styleFrom(backgroundColor: Colors.grey[300], foregroundColor: Colors.black87),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 16),
                TextFormField(
                  key: const Key('calories_field'),
                  controller: _caloriesController,
                  style: textStyle,
                  decoration: InputDecoration(labelText: 'Kalori* (contoh: 250)', labelStyle: labelStyle),
                  keyboardType: TextInputType.number,
                  validator: (value) {
                     if (value == null || value.isEmpty) {
                      return 'Kalori tidak boleh kosong';
                    }
                    if (int.tryParse(value) == null || int.parse(value) < 0) {
                      return 'Masukkan jumlah kalori yang valid';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                TextFormField(
                  key: const Key('servings_field'),
                  controller: _servingsController,
                  style: textStyle,
                  decoration: InputDecoration(labelText: 'Porsi* (contoh: 4)', labelStyle: labelStyle),
                  keyboardType: TextInputType.number,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Jumlah porsi tidak boleh kosong';
                    }
                    if (int.tryParse(value) == null || int.parse(value) <= 0) {
                      return 'Masukkan jumlah porsi yang valid';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                TextFormField(
                  key: const Key('cooking_minutes_field'),
                  controller: _cookingMinutesController,
                  style: textStyle,
                  decoration: InputDecoration(labelText: 'Waktu Memasak (Menit)* (contoh: 30)', labelStyle: labelStyle),
                  keyboardType: TextInputType.number,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Waktu memasak tidak boleh kosong';
                    }
                    if (int.tryParse(value) == null || int.parse(value) < 0) {
                      return 'Masukkan waktu memasak yang valid';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                // Difficulty Level ChoiceChips
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text("Tingkat Kesulitan*", style: GoogleFonts.dmSans(fontSize: 16, fontWeight: FontWeight.bold)),
                    const SizedBox(height: 8),
                    Wrap(
                      spacing: 8.0,
                      children: <Widget>[
                        ChoiceChip(
                          label: Text('Mudah', style: GoogleFonts.dmSans(fontSize: 13)),
                          selected: _selectedDifficultyLevel == 'easy',
                          onSelected: (bool selected) {
                            setState(() {
                              _selectedDifficultyLevel = selected ? 'easy' : (_selectedDifficultyLevel == 'easy' ? null : _selectedDifficultyLevel);
                            });
                          },
                          selectedColor: Colors.teal[100],
                          backgroundColor: Colors.grey[200],
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(16),
                            side: BorderSide(
                              color: _selectedDifficultyLevel == 'easy' ? Colors.teal : Colors.grey[400]!,
                            ),
                          ),
                        ),
                        ChoiceChip(
                          label: Text('Sedang', style: GoogleFonts.dmSans(fontSize: 13)),
                          selected: _selectedDifficultyLevel == 'medium',
                          onSelected: (bool selected) {
                            setState(() {
                               _selectedDifficultyLevel = selected ? 'medium' : (_selectedDifficultyLevel == 'medium' ? null : _selectedDifficultyLevel);
                            });
                          },
                          selectedColor: Colors.teal[100],
                          backgroundColor: Colors.grey[200],
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(16),
                            side: BorderSide(
                              color: _selectedDifficultyLevel == 'medium' ? Colors.teal : Colors.grey[400]!,
                            ),
                          ),
                        ),
                        ChoiceChip(
                          label: Text('Sulit', style: GoogleFonts.dmSans(fontSize: 13)),
                          selected: _selectedDifficultyLevel == 'hard',
                          onSelected: (bool selected) {
                            setState(() {
                              _selectedDifficultyLevel = selected ? 'hard' : (_selectedDifficultyLevel == 'hard' ? null : _selectedDifficultyLevel);
                            });
                          },
                          selectedColor: Colors.teal[100],
                          backgroundColor: Colors.grey[200],
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(16),
                            side: BorderSide(
                              color: _selectedDifficultyLevel == 'hard' ? Colors.teal : Colors.grey[400]!,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                // Removed erroneous wrapping TextFormField for ingredients.
                // Structured Ingredients Input (similar to create_recipe_screen)
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text("Bahan-Bahan*", style: GoogleFonts.dmSans(fontSize: 16, fontWeight: FontWeight.bold)),
                    const SizedBox(height: 8),
                      if (_ingredientRows.isEmpty)
                        Padding(
                          padding: const EdgeInsets.symmetric(vertical: 8.0),
                          child: Text("Belum ada bahan ditambahkan.", style: labelStyle),
                        ),
                    Column(
                      children: _ingredientRows.asMap().entries.map((entry) {
                        int idx = entry.key;
                        IngredientRowData rowData = entry.value;
                        return Card(
                          key: rowData.id,
                          margin: const EdgeInsets.symmetric(vertical: 4.0),
                          child: Padding(
                            padding: const EdgeInsets.all(8.0),
                            child: Column(
                              children: [
                                Row(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Expanded(
                                      flex: 4,
                                      child: TextFormField(
                                        controller: rowData.nameController,
                                        style: textStyle,
                                        decoration: InputDecoration(labelText: 'Nama Bahan*', labelStyle: labelStyle),
                                      ),
                                    ),
                                    const SizedBox(width: 8),
                                    Expanded(
                                      flex: 2,
                                      child: TextFormField(
                                        controller: rowData.quantityController,
                                        style: textStyle,
                                        decoration: InputDecoration(labelText: 'Jumlah*', labelStyle: labelStyle),
                                        keyboardType: const TextInputType.numberWithOptions(decimal: true),
                                      ),
                                    ),
                                    const SizedBox(width: 8),
                                    Expanded(
                                      flex: 2,
                                      child: TextFormField(
                                        controller: rowData.unitController,
                                        style: textStyle,
                                        decoration: InputDecoration(labelText: 'Satuan', labelStyle: labelStyle),
                                      ),
                                    ),
                                    if (_ingredientRows.length > 1)
                                      IconButton(
                                        icon: const Icon(Icons.remove_circle_outline, color: Colors.red),
                                        onPressed: () {
                                          setState(() {
                                            rowData.dispose();
                                            _ingredientRows.removeAt(idx);
                                          });
                                        },
                                      )
                                    else
                                      const SizedBox(width:48), // Placeholder for alignment
                                  ],
                                ),
                              ],
                            ),
                          ),
                        );
                      }).toList(),
                    ),
                    const SizedBox(height: 8),
                    ElevatedButton.icon(
                      onPressed: () {
                        setState(() {
                          _ingredientRows.add(IngredientRowData());
                        });
                      },
                      icon: const Icon(Icons.add_circle_outline),
                      label: const Text('Tambah Bahan'),
                      style: ElevatedButton.styleFrom(backgroundColor: Colors.green[100], foregroundColor: Colors.green[900]),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                // New Instructions UI
                Text("Instruksi*", style: GoogleFonts.dmSans(fontSize: 16, fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                if (_instructionSteps.isEmpty)
                  Padding(
                    padding: const EdgeInsets.symmetric(vertical: 8.0),
                    child: Text("Belum ada langkah instruksi ditambahkan.", style: labelStyle),
                  ),
                Column(
                  children: _instructionSteps.asMap().entries.map((entry) {
                    int idx = entry.key;
                    InstructionStepData stepData = entry.value;
                    return Card(
                      key: stepData.id, // Use unique key for the card
                      margin: const EdgeInsets.symmetric(vertical: 4.0),
                      child: Padding(
                        padding: const EdgeInsets.all(8.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Expanded(
                                  child: TextFormField(
                                    controller: stepData.textController,
                                    decoration: InputDecoration(
                                      labelText: 'Langkah ${idx + 1}*',
                                      hintText: 'Masukkan detail instruksi...',
                                      border: const OutlineInputBorder(),
                                    ),
                                    keyboardType: TextInputType.multiline,
                                    maxLines: null, // Allows unlimited lines
                                    validator: (value) {
                                      // Validator for individual step can be basic, main validation in _saveChanges
                                      if (value == null || value.trim().isEmpty) {
                                        // Only enforce if it's not the only empty step
                                        bool isOnlyEmptyStep = _instructionSteps.length == 1 && _instructionSteps.first.textController.text.trim().isEmpty && _instructionSteps.first.selectedImageFile == null && _instructionSteps.first.existingImageUrl == null;
                                        if (!isOnlyEmptyStep) {
                                          return 'Teks instruksi tidak boleh kosong.';
                                        }
                                      }
                                      return null;
                                    },
                                  ),
                                ),
                                if (_instructionSteps.length > 1)
                                  IconButton(
                                    icon: const Icon(Icons.remove_circle_outline, color: Colors.red),
                                    onPressed: () {
                                      setState(() {
                                        stepData.dispose();
                                        _instructionSteps.removeAt(idx);
                                        // TODO: If stepData.existingImageUrl was present, consider if the image file on server needs deletion.
                                      });
                                    },
                                  )
                                else
                                  const SizedBox(width: 48), // Placeholder for alignment
                              ],
                            ),
                            const SizedBox(height: 8),
                            Row(
                              children: [
                                ElevatedButton.icon(
                                  onPressed: () => _pickInstructionImage(idx),
                                  icon: const Icon(Icons.image_search),
                                  label: Text(stepData.selectedImageFile == null && stepData.existingImageUrl == null ? 'Tambah Gambar' : 'Ganti Gambar'),
                                  style: ElevatedButton.styleFrom(backgroundColor: Colors.grey[300], foregroundColor: Colors.black87),
                                ),
                                const SizedBox(width: 10),
                                // Display selected new image or existing image
                                if (stepData.selectedImageFile != null)
                                  Expanded(
                                    child: Stack(
                                      alignment: Alignment.topRight,
                                      children: [
                                        Image.file(
                                          stepData.selectedImageFile!,
                                          height: 60,
                                          fit: BoxFit.contain,
                                        ),
                                        IconButton( // Clear selected new image
                                          icon: const Icon(Icons.clear, color: Colors.red, size: 18),
                                          padding: EdgeInsets.zero,
                                          constraints: const BoxConstraints(),
                                          onPressed: () {
                                            setState(() {
                                              stepData.selectedImageFile = null;
                                            });
                                          },
                                        )
                                      ],
                                    ),
                                  )
                                else if (stepData.existingImageUrl != null)
                                  Expanded(
                                    child: Stack(
                                      alignment: Alignment.topRight,
                                      children: [
                                        Image.network(
                                          stepData.existingImageUrl!,
                                          height: 60,
                                          fit: BoxFit.contain,
                                          errorBuilder: (context, error, stackTrace) => const Icon(Icons.broken_image, size: 40),
                                        ),
                                        IconButton( // Clear existing image (sets URL to null for saving)
                                          icon: const Icon(Icons.delete_outline, color: Colors.red, size: 18),
                                           padding: EdgeInsets.zero,
                                          constraints: const BoxConstraints(),
                                          onPressed: () {
                                            setState(() {
                                              stepData.existingImageUrl = null;
                                              // TODO: Mark this image for server-side deletion upon saving the recipe
                                            });
                                          },
                                        )
                                      ],
                                    ),
                                  ),
                              ],
                            ),
                          ],
                        ),
                      ),
                    );
                  }).toList(),
                ),
                const SizedBox(height: 8),
                ElevatedButton.icon(
                  onPressed: () {
                    setState(() {
                      _instructionSteps.add(InstructionStepData());
                    });
                  },
                  icon: const Icon(Icons.add_circle_outline),
                  label: const Text('Tambah Langkah Instruksi'),
                  style: ElevatedButton.styleFrom(backgroundColor: Colors.teal[100], foregroundColor: Colors.teal[900]),
                ),
                const SizedBox(height: 24), // Maintain spacing before next section

                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text("Gambar Galeri (Opsional)", style: GoogleFonts.dmSans(fontSize: 16, fontWeight: FontWeight.bold)),
                      const SizedBox(height: 8),
                      ElevatedButton.icon(
                        key: const Key('pick_gallery_images_button_edit'),
                        onPressed: _isUploadingOrSaving ? null : _pickGalleryImages,
                        style: ElevatedButton.styleFrom(backgroundColor: Colors.grey[300], foregroundColor: Colors.black87),
                        icon: const Icon(Icons.photo_library),
                        label: const Text('Tambah Gambar Galeri Lainnya'),
                      ),
                      const SizedBox(height: 8),
                      if (_existingGalleryImageUrls.isNotEmpty || _newSelectedGalleryImageFiles.isNotEmpty)
                        SizedBox(
                          height: 120,
                          child: ListView.builder(
                            scrollDirection: Axis.horizontal,
                            itemCount: _existingGalleryImageUrls.length + _newSelectedGalleryImageFiles.length,
                            itemBuilder: (context, index) {
                              Widget imageWidget;
                              bool isNewFile = index >= _existingGalleryImageUrls.length;

                              if (isNewFile) {
                                imageWidget = Image.file(_newSelectedGalleryImageFiles[(index - _existingGalleryImageUrls.length).toInt()], fit: BoxFit.cover);
                              } else {
                                imageWidget = Image.network(_existingGalleryImageUrls[index], fit: BoxFit.cover,
                                  errorBuilder: (context, error, stackTrace) => const Icon(Icons.broken_image, size: 50),
                                );
                              }

                              return Padding(
                                padding: const EdgeInsets.only(right: 8.0),
                                child: Stack(
                                  children: [
                                    Container(
                                      width: 100,
                                      height: 100,
                                      decoration: BoxDecoration(border: Border.all(color: Colors.grey)),
                                      child: imageWidget,
                                    ),
                                    Positioned(
                                      top: -10,
                                      right: -10,
                                      child: IconButton(
                                        icon: const Icon(Icons.remove_circle, color: Colors.red, size: 20),
                                        onPressed: () {
                                          setState(() {
                                            if (isNewFile) {
                                              _newSelectedGalleryImageFiles.removeAt((index - _existingGalleryImageUrls.length).toInt());
                                            } else {
                                              _existingGalleryImageUrls.removeAt(index);
                                            }
                                          });
                                        },
                                      ),
                                    ),
                                  ],
                                ),
                              );
                            },
                          ),
                        )
                      else
                        Text("Belum ada gambar galeri.", style: GoogleFonts.dmSans()),
                    ],
                  ),
                ),
                const SizedBox(height: 32),
                _isUploadingOrSaving
                  ? const Center(child: CircularProgressIndicator())
                  : ElevatedButton(
                      key: const Key('save_button'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.blueAccent,
                        padding: const EdgeInsets.symmetric(vertical: 16),
                        // textStyle: GoogleFonts.dmSans(fontSize: 18, fontWeight: FontWeight.bold), // Text widget below defines style
                      ),
                      onPressed: _saveChanges,
                      child: Text('Simpan Perubahan', style: GoogleFonts.dmSans(fontSize: 18, fontWeight: FontWeight.bold)),
                    ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildTagSelectionSection<T>({
    required String title,
    required List<T> availableTags,
    required Set<int> selectedTagIds,
    required Function(bool, int) onSelected,
  }) {
    final labelStyle = GoogleFonts.dmSans(fontSize: 14, color: Colors.grey[700]);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: GoogleFonts.dmSans(fontSize: 16, fontWeight: FontWeight.bold)),
        const SizedBox(height: 8),
        if (availableTags.isEmpty && !_isLoadingTags)
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0),
            child: Text("Tidak ada ${title.toLowerCase().split(' ')[0]} tersedia untuk dipilih.", style: labelStyle),
          )
        else
          Wrap(
            spacing: 8.0,
            runSpacing: 4.0,
            children: availableTags.map((tag) {
              final tagId = (tag as dynamic).id as int;
              final tagName = (tag as dynamic).name as String;
              return ChoiceChip(
                label: Text(tagName, style: GoogleFonts.dmSans(fontSize: 13)),
                selected: selectedTagIds.contains(tagId),
                onSelected: (selected) {
                  onSelected(selected, tagId);
                },
                selectedColor: Colors.teal[100],
                backgroundColor: Colors.grey[200],
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(16),
                  side: BorderSide(
                    color: selectedTagIds.contains(tagId) ? Colors.teal : Colors.grey[400]!,
                  ),
                ),
              );
            }).toList(),
          ),
      ],
    );
  }
}
