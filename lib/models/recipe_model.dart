// ignore_for_file: non_constant_identifier_names

class RecipeIngredientModel {
  int? id;
  int? recipe_id; // Nullable because it's set after recipe is created
  String ingredient_text; // Maps to 'ingredients' text column in DB, e.g., "Flour", "2 large eggs"
  double quantity;
  String? unit;
  String? notes;
  int order_index;

  RecipeIngredientModel({
    this.id,
    this.recipe_id,
    required this.ingredient_text, // Changed from 'name' and removed 'ingredient_id'
    required this.quantity,
    this.unit,
    this.notes,
    this.order_index = 0,
  });

  factory RecipeIngredientModel.fromJson(Map<String, dynamic> json) {
    return RecipeIngredientModel(
      id: json['id'] as int?,
      recipe_id: json['recipe_id'] as int?,
      // The 'ingredients' column from DB is the text of the ingredient
      ingredient_text: json['ingredients'] as String,
      quantity: (json['quantity'] as num).toDouble(),
      unit: json['unit'] as String?,
      notes: json['notes'] as String?,
      order_index: json['order_index'] as int? ?? 0,
    );
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = {
      'recipe_id': recipe_id,
      'ingredients': ingredient_text, // Maps to the 'ingredients' text column
      'quantity': quantity,
      'unit': unit,
      'notes': notes,
      'order_index': order_index,
    };
    data.removeWhere((key, value) => value == null && key != 'notes' && key != 'unit');
    if (id != null) {
      data['id'] = id;
    }
    return data;
  }
}

class RecipeInstructionModel {
  int? id;
  int? recipe_id; // Nullable because it's set after recipe is created
  int step_number;
  String instruction;
  String? image_url;
  int? estimated_time_minutes;

  RecipeInstructionModel({
    this.id,
    this.recipe_id,
    required this.step_number,
    required this.instruction,
    this.image_url,
    this.estimated_time_minutes,
  });

  factory RecipeInstructionModel.fromJson(Map<String, dynamic> json) {
    return RecipeInstructionModel(
      id: json['id'] as int?,
      recipe_id: json['recipe_id'] as int?,
      step_number: json['step_number'] as int,
      instruction: json['instruction'] as String,
      image_url: json['image_url'] as String?,
      estimated_time_minutes: json['estimated_time_minutes'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = {
      'recipe_id': recipe_id,
      'step_number': step_number,
      'instruction': instruction,
      'image_url': image_url,
      'estimated_time_minutes': estimated_time_minutes,
    };
    // Remove nulls, except for fields explicitly nullable in DB
    data.removeWhere((key, value) => value == null && key != 'image_url' && key != 'estimated_time_minutes');
    if (id != null) {
      data['id'] = id;
    }
    return data;
  }
}

class RecipeModel {
  int? id; // Nullable because it's auto-generated by DB on create
  String user_id; // UUID, will be string in Dart
  String title;
  String? description;
  String? image_url; // Main image
  int? calories;
  int servings;
  int cooking_time_minutes;
  String difficulty_level;
  bool is_published;
  DateTime? created_at; // Nullable on create, auto-set by DB
  DateTime? updated_at; // Nullable on create, auto-set by DB

  // Structured data for ingredients and instructions
  List<RecipeIngredientModel>? ingredients;
  List<RecipeInstructionModel>? instructions;

  // Temporary fields for text input from UI
  String? ingredients_text;
  String? directions_text;
  List<String>? gallery_image_urls;

  RecipeModel({
    this.id,
    required this.user_id,
    required this.title,
    this.description,
    this.image_url,
    this.calories,
    required this.servings,
    required this.cooking_time_minutes,
    this.difficulty_level = 'medium',
    this.is_published = true,
    this.created_at,
    this.updated_at,
    this.ingredients,
    this.instructions,
    this.ingredients_text, // Keep for UI data transfer
    this.directions_text,  // Keep for UI data transfer
    this.gallery_image_urls,
  });

  factory RecipeModel.fromJson(Map<String, dynamic> json) {
    print("Parsing RecipeModel.fromJson. Input JSON keys: ${json.keys.toList()}");

    // Helper function for robust list parsing
    List<T>? _parseList<T>(dynamic listData, String fieldName, T Function(Map<String, dynamic>) fromJsonCreator) {
      print("Attempting to parse list '$fieldName'. Type: ${listData?.runtimeType}, Value: $listData");
      if (listData == null) return null;
      if (listData is List) {
        if (listData.isEmpty) return []; // Return empty list if input is empty list
        return listData.map((item) {
          print("Processing item for '$fieldName': Type: ${item?.runtimeType}, Value: $item");
          if (item is Map<String, dynamic>) {
            try {
              return fromJsonCreator(item);
            } catch (e, s) {
              print('Error parsing item for $fieldName: $item, error: $e, stack: $s');
              return null;
            }
          } else {
            print('Skipping non-map item in $fieldName: $item of type ${item.runtimeType}');
            return null;
          }
        }).whereType<T>().toList();
      } else {
        print("ERROR: '$fieldName' is not a List, but type ${listData.runtimeType}. Value: $listData");
        return null;
      }
    }

    // Helper function for robust gallery image URL list parsing
    List<String>? _parseGalleryImageUrls(dynamic listData) {
      print("Attempting to parse list 'recipe_gallery_images'. Type: ${listData?.runtimeType}, Value: $listData");
      if (listData == null) return null;
      if (listData is List) {
        if (listData.isEmpty) return [];
        return listData.map((item) {
          print("Processing item for 'recipe_gallery_images': Type: ${item?.runtimeType}, Value: $item");
          if (item is Map<String, dynamic>) {
            if (item['image_url'] is String) {
              return item['image_url'] as String;
            } else {
              print("Skipping gallery item due to missing or invalid 'image_url': $item");
              return null;
            }
          } else {
            print('Skipping non-map item in recipe_gallery_images: $item of type ${item.runtimeType}');
            return null;
          }
        }).whereType<String>().toList();
      } else {
        print("ERROR: 'recipe_gallery_images' is not a List, but type ${listData.runtimeType}. Value: $listData");
        return null;
      }
    }

    // User parsing - assuming 'users' is a single map or null
    // For now, we are not creating a UserModel, just checking structure.
    // If 'users' field is critical and has its own model, it should be parsed similarly.
    final usersData = json['users'];
    print("Attempting to parse 'users'. Type: ${usersData?.runtimeType}, Value: $usersData");
    if (usersData != null && !(usersData is Map<String, dynamic>)) {
      print("ERROR: 'users' field is not a Map<String, dynamic>, but type ${usersData.runtimeType}. Value: $usersData");
      // Decide how to handle this - throw error, or make user_id parsing more defensive if users is not a map.
      // For now, the user_id parsing below might fail if users is not a map.
    }


    return RecipeModel(
      id: json['id'] as int?,
      user_id: json['user_id'] as String, // This assumes user_id is always top-level
      title: json['title'] as String,
      description: json['description'] as String?,
      image_url: json['image_url'] as String?,
      calories: json['calories'] as int?,
      servings: json['servings'] as int? ?? 1,
      cooking_time_minutes: json['cooking_time_minutes'] as int,
      difficulty_level: json['difficulty_level'] as String? ?? 'medium',
      is_published: json['is_published'] as bool? ?? true,
      created_at: json['created_at'] != null ? DateTime.tryParse(json['created_at'] as String) : null,
      updated_at: json['updated_at'] != null ? DateTime.tryParse(json['updated_at'] as String) : null,

      ingredients: _parseList(json['recipe_ingredients'], 'recipe_ingredients', RecipeIngredientModel.fromJson),
      instructions: _parseList(json['recipe_instructions'], 'recipe_instructions', RecipeInstructionModel.fromJson),
      gallery_image_urls: _parseGalleryImageUrls(json['recipe_gallery_images']),
    );
  }

  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = {
      'user_id': user_id,
      'title': title,
      'description': description,
      'image_url': image_url,
      'calories': calories,
      'servings': servings,
      'cooking_time_minutes': cooking_time_minutes,
      'difficulty_level': difficulty_level,
      'is_published': is_published,
      // id, created_at, updated_at are handled by DB
    };

    // ingredients and instructions are not part of the main 'recipes' table JSON.
    // They will be handled separately by the service.
    // ingredients_text and directions_text are also not part of the 'recipes' table.
    // gallery_image_urls are also handled separately.

    data.removeWhere((key, value) => value == null && key != 'description' && key != 'image_url' && key != 'calories');
    return data;
  }
}

// Example Usage (for testing the model):
/*
void main() {
  // From JSON (simulating data from Supabase with joined ingredients/instructions)
  Map<String, dynamic> supabaseData = {
    'id': 1,
    'user_id': 'some-uuid-string',
    'title': 'Pancakes',
    'description': 'Delicious fluffy pancakes.',
    'image_url': 'http://example.com/pancakes.jpg',
    'calories': 300,
    'servings': 4,
    'cooking_time_minutes': 20,
    'difficulty_level': 'easy',
    'is_published': true,
    'created_at': DateTime.now().toIso8601String(),
    'updated_at': DateTime.now().toIso8601String(),
    'recipe_gallery_images': [
      {'image_url': 'http://example.com/gallery1.jpg'},
      {'image_url': 'http://example.com/gallery2.jpg'}
    ],
    'recipe_ingredients': [
      {
        'id': 10,
        'recipe_id': 1,
        'ingredient_id': 100,
        'name': 'Flour', // This would come from a join with 'ingredients' table
        'quantity': 1.5,
        'unit': 'cup',
        'order_index': 0
      },
      {
        'id': 11,
        'recipe_id': 1,
        'ingredient_id': 101,
        'name': 'Sugar',
        'quantity': 2,
        'unit': 'tbsp',
        'order_index': 1
      }
    ],
    'recipe_instructions': [
      {
        'id': 20,
        'recipe_id': 1,
        'step_number': 1,
        'instruction': 'Mix ingredients.'
      },
      {
        'id': 21,
        'recipe_id': 1,
        'step_number': 2,
        'instruction': 'Cook on pan.'
      }
    ]
  };

  RecipeModel recipe = RecipeModel.fromJson(supabaseData);
  print('Recipe Title: ${recipe.title}');
  print('First Ingredient: ${recipe.ingredients?.first.name} ${recipe.ingredients?.first.quantity} ${recipe.ingredients?.first.unit}');
  print('First Instruction: ${recipe.instructions?.first.instruction}');
  print('First Gallery Image: ${recipe.gallery_image_urls?.first}');


  // To JSON (simulating data to send to Supabase for the main 'recipes' table)
  // Note: toJson for RecipeModel itself doesn't include ingredients/instructions
  // as they are saved to different tables.
  Map<String, dynamic> recipeJson = recipe.toJson();
  print('Recipe JSON for Supabase (main table): $recipeJson');

  // Creating a new recipe
  RecipeModel newRecipe = RecipeModel(
    user_id: 'another-uuid',
    title: 'Omelette',
    servings: 1,
    cooking_time_minutes: 10,
    difficulty_level: 'easy',
    // UI would provide these text fields
    ingredients_text: '2 large Eggs\n1 pinch Salt\nPepper to taste',
    directions_text: 'Whisk eggs.\nCook in pan.',
    gallery_image_urls: ['http://example.com/omelette_gallery.jpg'],
    // These would be populated by parsing ingredients_text and directions_text
    ingredients: [
      RecipeIngredientModel(ingredient_id: 200, name: 'Eggs', quantity: 2, unit: 'large'),
      RecipeIngredientModel(ingredient_id: 201, name: 'Salt', quantity: 1, unit: 'pinch'),
      RecipeIngredientModel(ingredient_id: 202, name: 'Pepper', quantity: 1, unit: 'to taste'),
    ],
    instructions: [
      RecipeInstructionModel(step_number: 1, instruction: 'Whisk eggs.'),
      RecipeInstructionModel(step_number: 2, instruction: 'Cook in pan.'),
    ]
  );

  Map<String, dynamic> newRecipeJson = newRecipe.toJson();
  print('New Recipe JSON for Supabase (main table): $newRecipeJson');

  // Example of RecipeIngredientModel to JSON
  print('First ingredient to JSON: ${newRecipe.ingredients?.first.toJson()}');
  // Example of RecipeInstructionModel to JSON
  print('First instruction to JSON: ${newRecipe.instructions?.first.toJson()}');
}
*/
